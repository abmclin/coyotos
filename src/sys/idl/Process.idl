package coyotos;

/// @brief Operations common to all Coyotos processes.
///
/// This is the architecture-independent process interface. For many
/// operations of interest the architecture dependent interface should
/// be consulted.
abstract interface Process extends Cap {
  /// @brief Process execution model (architecture).
  ///
  /// This is primarily useful on machines that support (directly or
  /// through simulation) mutiple execution models. It allows a
  /// debugger to learn the execution model (architecture) of a
  /// subject process.
  unsigned long enum arch {
    /// @brief Intel IA32 (and derivatives)
    ia32,
    /// @brief Later coldfire processors
    coldfireV4,
    /// @brief Acorn RISC Machine
    arm,
    /// @brief AMD64
    amd64,
    /// @brief Sun 32-bit SPARC
    sparc,
    /// @brief Sun 64-bit SPARC
    sparc64,
    /// @brief Intel ITANIC
    ia64
  };

  /// @brief Fault (exception) codes.
  ///
  /// The fault code provides a mostly machine independent renaming of
  /// the exception codes returned by the processor, plus a small
  /// number of additional exceptions generated by kernel
  /// software. Some architectures (notably IA32) extend this code
  /// space with additional, architecture-specific extensions. FC code
  /// points beginning at 128 are reserved for architecture-specific
  /// fault codes.
  unsigned byte enum FC {
    /// @brief Process currently does not have any fault.
    NoFault = 0,

    /// @brief System call parameters were malformed, or system call
    /// number unknown.
    MalformedSyscall = 1,

    /// @brief An application-defined interrupt is being delivered.
    SoftNotice = 2,

    /// @brief Slice expiration occurred.
    SliceExpired = 3,

    /// @brief Issued address was undefined.
    InvalidAddr = 4,

    /// @brief Insufficient access rights for instruction reference.
    ///
    /// Note that this exception will be generated only on machines
    /// that provide the NX permission bit or equivalent
    /// functionality.
    NoExecute = 5,

    /// @brief Cannot write to specified address.
    AccessViolation = 6,

    /// @brief A data load/store was attempted to a capability page.
    DataAccessTypeError = 7,

    /// @brief A capability load/store was attempted to a data page or
    /// I/O page.
    CapAccessTypeError = 8,

    /// @brief Reference to item at misaligned address. Note that this
    /// is not considered a memory error.
    MisalignedReference = 9,

    /// @brief GPT traversal limit exceeded in address space reference.
    TraverseLimit = 12, 

    /// @brief Address space GPT arrangement is malformed, or GPT
    /// contains an inappropriate capability type.
    MalformedSpace = 13,

    /// @brief Issued to ensure notification delivery to in-process 
    /// fault handler.
    Notify = 24,

    /// @brief Issued when a process is first made running to allow
    /// activation handler to initialize.
    Startup = 25,

    /// @brief Process has invalid/maltyped address space capability.
    ///
    /// @bug Not sure this can ever be issued -- won't this simply
    /// manifest as one of DataInvalidAddr, CapInvalidAddr, or
    /// IOInvalidAddr?
    NoAddrSpace = 32,

    /// @brief Process has invalid/maltyped schedule capability.
    NoSchedule = 33,

    /// @brief Process encountered a breakpoint instruction (PC=@&bpt).
    ///
    /// This fault code is used on architectures where the breakpoint
    /// instruction does not advance the program counter, or when the
    /// kernel can automatically roll the program counter back to
    /// point to the breakpoint instruction.
    BreakPoint = 34,

    /// @brief Process encountered a breakpoint instruction (PC=@&bpt+1).
    ///
    /// This fault code is used on architectures where it is
    /// impossible to automatically recover the correct address of the
    /// breakpoint instruction. On architectures where the address of
    /// the breakpoint instruction can be reliably re-established in
    /// software, the kernel will back up the instruction pointer and
    /// report the BreakPoint exception instead.
    BrokePoint = 35,

    /// @brief Process issued an illegal or unknown instruction.
    BadOpcode = 36,

    /// @brief Process marked as ``alien'' performed an invocation
    /// instruction.
    Alien = 37,

    /// @brief Process performed an integer divide by zero
    DivZero = 38,

    /// @brief Process performed a checked misaligned memory reference.
    BadAlign = 39,
    
    /// @brief No floating point unit available.
    ///
    /// This exception indicates that there is neither a hardware
    /// floating point unit nor a kernel-provided software emulation
    /// available on this machine.
    NoFPU = 40,

    /// @brief Unsupported floating point instruction.
    ///
    /// Other floating point error. More detailed information about
    /// the error should be obtained by executing the architecture
    /// specific GetRegsFP() operation and examining the appropriate
    /// floating point status register.
    FPfault = 41,

    /// @brief Debug Exception
    ///
    /// A hardware debugging event has occurred.
    Debug = 42,

    /// @brief Overflow trap.
    Overflow = 44,

    /// @brief Bounds Violation.
    Bounds = 45,

    /// @brief Trap on Start of Invocation
    SysCallEntry = 46,

    /// @brief Trap on Post-Receive
    SysCallReturn = 47,

    /// @brief Trap on Post-Receive
    ActivationFail = 48,

    /// @brief Backing store has unrecoverably lost the state of this object.
    ObjectContentLost = 49,

    /* IA-32 specific trap codes: */

    /// @brief General Protection fault.
    GeneralProtection = 128,

    /// @brief Stack Segment fault.
    StackSeg = 129,

    /// @brief Segment Not Present fault.
    SegNotPresent = 130,

    /// @brief SIMD floating point error.
    SIMDfp = 131
  };

  // /// @brief Stop the process.
  // ///
  // /// Transitions the process to the idle state. When idle, a process
  // /// will not attempt to initiate new instructions.
  // void stop() raises (NoAccess);

  /// @brief Resume the process.
  ///
  /// Transitions the process to the ready state. When ready, a
  /// process will initiate new instructions according to its
  /// schedule, and may make progress in an invocation. If cancelFault
  /// is true, resume the process with its fault code set to
  /// FC.NoFault.
  void resume(boolean cancelFault) raises (NoAccess);

  /// @brief Sets the address space and PC value as a single
  /// operation, and transitions the target process to the running
  /// state.
  ///
  /// Atomically installs @p newAS in the address space slot and @p
  /// newPC in the program counter slot.  Typically used by a process
  /// on itself to switch to/from protospace.
  ///
  /// If the operation is performed on the invoker, the load multiple
  /// caps and send phase are marked completed in the invoker register
  /// set. If the operation is performed on the invokee, these phases
  /// will already have completed.
  ///
  /// Note that if this operation is performed on the invoker, it
  /// effectively causes the system call to be aborted after a
  /// successful kernel operation but without a receive or store
  /// multiple capabilities phase during the current kernel
  /// invocation. If this operation is performed on the invokee, the
  /// invokee is logically made running immediately, with the effect
  /// that the invokee receive phase is similarly terminated and no
  /// store multiple capabilities phase occurs during the current
  /// kernel invocation.
  ///
  /// The phrase "during the current kernel invocation" addresses a
  /// peculiar corner case. If the target process PC and AS point to
  /// the system call trap instruction prior to invocation, and the
  /// result of setSpaceAndPC is to set them to their prior values,
  /// the target process will resume by re-executing the system call
  /// trap. Depending on how much progress the target process has made
  /// during its system call, it may or may not then complete the
  /// system call by performing a receive phase and/or a store
  /// multiple capabilities phase. Note, however, that these actions
  /// will occur in the @em subsequent invocation.
  void setSpaceAndPC(Cap newAS, archaddr_t newPC); 

  /// @brief Capability slots of a process.
  ///
  /// <b>This is obsolete</b>
  unsigned long enum cslot {
    /// @brief Fault handler.
    handler,
    /// @brief Address space.
    addrSpace,
    /// @brief Schedule.
    schedule,
    /// @brief IO address space
    ioSpace,
    /// @brief Cohort capability.
    cohort
  };

  /// @brief Retrieve the capability stored in the specified
  /// capability slot.
  Cap getSlot(cslot slot);

  /// @brief Store the supplied capability stored to the specified
  /// capability slot. If the type of the stored capability is
  /// unsuitable for the slot, the RequestError exception is raised.
  void setSlot(cslot slot, Cap c) raises(RequestError);

  typedef unsigned long capreg_t;

  /// @brief Retrieve the capability stored in the specified
  /// capability register.
  ///
  /// If @p reg is out of bounds (@>= 32), the RequestError exception is raised.
  Cap getCapReg(capreg_t reg) raises (RequestError);

  /// @brief Store the supplied capability stored to the specified
  /// capability register.
  ///
  /// If @p reg is out of bounds (@>= 32), the RequestError exception is raised.
  /// If @p reg is zero, the RequestError exception is raised.
  void setCapReg(capreg_t reg, Cap c) raises(RequestError);

  /// @brief Identify whether the passed entry capability @p ent is an
  /// entry capability to a process whose brand matches ours.
  /// 
  /// Returns true if @p ent is an entry capability, and the
  /// <tt>brand</tt> slot of the process designated (indirectly) by
  /// the entry capability matches the <tt>brand</tt> slot of the
  /// invoked process.  Otherwise, returns false, @p epID and @p pp are
  /// zero, and @p isMe is false.
  ///
  /// If the capability @p ent @em is a peer entry capability, returns
  /// the endpoint ID value in @p epID and the entry capability's
  /// protected payload value in @p pp. If the endpoint names the
  /// invoked process capability, @p isMe will be true.
  ///
  boolean identifyEntry(Cap ent, 
			out payload_t pp,
			out unsigned long long epID, 
			out boolean isMe);

  /// @brief Identify whether the passed entry capability @p ent is an
  /// entry capability to a peer thread.
  /// 
  /// Return true if @p ent is an entry capability, and the
  /// <tt>cohort</tt> slot of the process designated (indirectly) by
  /// the entry capability matches the <tt>cohort</tt> slot of the
  /// invoked process.
  ///
  /// If the capability @p ent @em does name a peer process, returns
  /// the endpoint ID value in @p epID, the entry capability's
  /// protected payload value in @p pp, and the peer process
  /// capability in @p peer.
  boolean amplifyCohortEntry(Cap ent, 
			     out payload_t pp,
			     out unsigned long long epID, 
			     out Process peer);
};
